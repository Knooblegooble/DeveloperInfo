<!DOCTYPE html><html data-bs-theme="light" lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, shrink-to-fit=no"><title>Home - Brand</title><link rel="stylesheet" href="assets/bootstrap/css/bootstrap.min.css"><link rel="stylesheet" href="assets/fonts/font-awesome.min.css"><link rel="stylesheet" href="assets/css/styles.min.css"></head><body id="page-top" style="color: #00ff0a;background: var(--bs-emphasis-color);"><script type="importmap">
		{
			"imports": {
				"three": "../build/three.module.js",
				"three/addons/": "./jsm/"
			}
		}
</script>
<div class="container-fluid my-auto text-center" style="font-family: 'Bungee Hairline', serif;color: var(--bs-body-bg);"><h1 style="font-size: 68.88px;padding-top: 40px;">Kaleb Knoettgen				<div class="caption v-middle text-center">
					<h1 class="cd-headline clip">
			            <span style="font-size: 40px;" class="cd-words-wrapper">
			              <b class="is-visible">Game Designer.</b>
			              <b>Unreal Engine Developer.</b>
			              <b>Generative AI Specialist.</b>
			              <b>Full-Stack XR Expertice.</b>
			            </span>
	          		</h1>
				</div>

<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
</h1><h3 class="mb-5"><em class="text-warning">Knooblegooble</em></h3></div><div class="container-fluid" style="padding: 0;"><div class="hstack shadow d-lg-flex justify-content-lg-center align-items-lg-center" style="background: linear-gradient(black 0%, var(--bs-body-color) 61%, var(--bs-body-color) 92%, rgb(0,0,0) 100%), var(--bs-secondary-color);color: var(--bs-body-bg);"><a href="#SmackInfo"><div id="cd1" style="width: 250px;height: 250px;border-color: var(--bs-body-color);">	<script type="module">

	import * as THREE from 'three';
	import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
	import { RenderPixelatedPass } from 'three/addons/postprocessing/RenderPixelatedPass.js';
	import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
	import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

	let camera, scene, renderer, composer, clock, mixer;
	let animations; // Store animations here
	let params, model;
	let modelBoundingBox, boundingBoxHelper;

	const myContainer = 'cd1';

	init();
	animate();

	function init()
	{
		// Global variables
		const container = document.getElementById(myContainer);
		const containerWidth = container.clientWidth;
		const containerHeight = container.clientHeight;
		const aspectRatio = containerWidth / containerHeight;
		clock = new THREE.Clock();
		scene = new THREE.Scene();
		params = {
			pixelSize: 2,
			normalEdgeStrength: .3,
			depthEdgeStrength: .4,
			pixelAlignedPanning: true
		};
		
		// Camera setup
		camera = new THREE.OrthographicCamera(-aspectRatio, aspectRatio, 1, -1, 0.1, 10);
		camera.position.set(0, 1, 5);
		camera.lookAt(scene.position);
		camera.zoom = 7;
		
		// Renderer setup
		renderer = new THREE.WebGLRenderer(
		{
			antialias: true,
			alpha: true // Enable transparency
		});
		renderer.shadowMap.enabled = true;
		renderer.setSize(containerWidth, containerHeight);
		container.appendChild(renderer.domElement); // Append to the container
		composer = new EffectComposer(renderer);
		const renderPixelatedPass = new RenderPixelatedPass(2, scene, camera);
		composer.addPass(renderPixelatedPass);
		const outputPass = new OutputPass();
		composer.addPass(outputPass);



		// lights
		scene.add(new THREE.AmbientLight(0x757f8e, 3));
		const directionalLight = new THREE.DirectionalLight(0xfffecd, 1.5);
		directionalLight.position.set(100, 100, 100);
		directionalLight.castShadow = true;
		directionalLight.shadow.mapSize.set(2048, 2048);
		scene.add(directionalLight);

		const spotLight = new THREE.SpotLight(0xffc100, 10, 10, Math.PI / 16, .02, 2);
		spotLight.position.set(2, 2, 0);
		const target = spotLight.target;
		scene.add(target);
		target.position.set(0, 0, 0);
		spotLight.castShadow = true;
		scene.add(spotLight);
		

		// Handle Models
		const loader = new GLTFLoader().setPath('models/web/');
		loader.load('smack/cdsmack.gltf', async function(gltf) {
			model = gltf.scene;
			animations = gltf.animations;
			mixer = new THREE.AnimationMixer(model);

			await renderer.compileAsync(model, camera, scene);
			scene.add(model);
			
			//Initialize the bounding box and its helper
			modelBoundingBox = new THREE.Box3().setFromObject(model);
			boundingBoxHelper = new THREE.Box3Helper(modelBoundingBox, 0xff0000);
			//scene.add(boundingBoxHelper); // Optional: Add the bounding box helper for visualization
			//modelBoundingBox.addEventListener('mouseclick', onModelClick);
		
		});
		
		

		// Events to listen to
		window.addEventListener('resize', onWindowResize);
		container.addEventListener('mousemove', onMouseMove);
		container.addEventListener('mouseleave', onMouseMove);

	}



	function onMouseMove(event) {
		event.preventDefault();

		const raycaster = new THREE.Raycaster();
		const mouse = new THREE.Vector2();
		const bounds = renderer.domElement.getBoundingClientRect();

		mouse.x = ((event.clientX - bounds.left) / bounds.width) * 2 - 1;
		mouse.y = -((event.clientY - bounds.top) / bounds.height) * 2 + 1;
		raycaster.setFromCamera(mouse, camera);

		// Update the bounding box to the current state of the model.
		//const currentBoundingBox = new THREE.Box3().setFromObject(model);

		if (modelBoundingBox && raycaster.ray.intersectBox(modelBoundingBox, new THREE.Vector3())) {
			document.body.style.cursor = 'pointer'; // Change cursor to indicate interactive element
			if (!model.userData.isHovered) {
				model.userData.isHovered = true; // Flag to indicate hover state
				playAnimation(1); // Play animation forwards only if it wasn't already hovering
			}
		} else {
			document.body.style.cursor = 'default'; // Change cursor back to default
			if (model.userData.isHovered) {
				model.userData.isHovered = false; // Reset hover state flag
				playAnimation(-1); // Play animation in reverse since mouse has left
			}
		}
	}

	function playAnimation(direction) {
		// Function to control animation playback
		if (mixer && animations.length > 0) {
			const action = mixer.clipAction(animations[0]);
			action.setEffectiveTimeScale(direction); // Direction controls the playback direction
			if(direction === 1 && !action.isRunning()) {
				action.setLoop(THREE.LoopOnce);
				action.clampWhenFinished = true;
				action.enabled = true;
				action.play();
			} else if(direction === -1) {
				action.enabled = true;
				action.paused = false;
				action.clampWhenFinished = false;
				action.play();
			}
		}
	}

	function animate()
	{

		requestAnimationFrame(animate);


		// Ensure mixer is defined before attempting to update it
		if (mixer) mixer.update(clock.getDelta());

		const t = clock.getElapsedTime();
		
		
		// Update the bounding box and helper in every frame
		if (model && modelBoundingBox) {
			modelBoundingBox.setFromObject(model);
		}

		// Pixel Effect
		const rendererSize = renderer.getSize(new THREE.Vector2());
		const aspectRatio = rendererSize.x / rendererSize.y;
		if (params['pixelAlignedPanning'])
		{

			pixelAlignFrustum(camera, aspectRatio, Math.floor(rendererSize.x / params['pixelSize']),
				Math.floor(rendererSize.y / params['pixelSize']));

		}
		else if (camera.left != -aspectRatio || camera.top != 1.0)
		{

			// Reset the Camera Frustum if it has been modified
			camera.left = -aspectRatio;
			camera.right = aspectRatio;
			camera.top = 1.0;
			camera.bottom = -1.0;
			camera.updateProjectionMatrix();

		}

		composer.render();

	}
	
	// Helper
	
	function onWindowResize()
	{
		const container = document.getElementById(myContainer);
		const containerWidth = container.clientWidth;
		const containerHeight = container.clientHeight;
		const aspectRatio = containerWidth / containerHeight;
		camera.left = -aspectRatio;
		camera.right = aspectRatio;
		camera.updateProjectionMatrix();

		renderer.setSize(containerWidth, containerHeight);
		composer.setSize(containerWidth, containerHeight);
	}
	
	


	function pixelTexture(texture)
	{

		texture.minFilter = THREE.NearestFilter;
		texture.magFilter = THREE.NearestFilter;
		texture.generateMipmaps = false;
		texture.wrapS = THREE.RepeatWrapping;
		texture.wrapT = THREE.RepeatWrapping;
		texture.colorSpace = THREE.SRGBColorSpace;
		return texture;

	}

	function pixelAlignFrustum(camera, aspectRatio, pixelsPerScreenWidth, pixelsPerScreenHeight)
	{

		// 0. Get Pixel Grid Units
		const worldScreenWidth = ((camera.right - camera.left) / camera.zoom);
		const worldScreenHeight = ((camera.top - camera.bottom) / camera.zoom);
		const pixelWidth = worldScreenWidth / pixelsPerScreenWidth;
		const pixelHeight = worldScreenHeight / pixelsPerScreenHeight;

		// 1. Project the current camera position along its local rotation bases
		const camPos = new THREE.Vector3();
		camera.getWorldPosition(camPos);
		const camRot = new THREE.Quaternion();
		camera.getWorldQuaternion(camRot);
		const camRight = new THREE.Vector3(1.0, 0.0, 0.0).applyQuaternion(camRot);
		const camUp = new THREE.Vector3(0.0, 1.0, 0.0).applyQuaternion(camRot);
		const camPosRight = camPos.dot(camRight);
		const camPosUp = camPos.dot(camUp);

		// 2. Find how far along its position is along these bases in pixel units
		const camPosRightPx = camPosRight / pixelWidth;
		const camPosUpPx = camPosUp / pixelHeight;

		// 3. Find the fractional pixel units and convert to world units
		const fractX = camPosRightPx - Math.round(camPosRightPx);
		const fractY = camPosUpPx - Math.round(camPosUpPx);

		// 4. Add fractional world units to the left/right top/bottom to align with the pixel grid
		camera.left = -aspectRatio - (fractX * pixelWidth);
		camera.right = aspectRatio - (fractX * pixelWidth);
		camera.top = 1.0 - (fractY * pixelHeight);
		camera.bottom = -1.0 - (fractY * pixelHeight);
		camera.updateProjectionMatrix();

	}

</script></div></a><a href="#SmackInfo"><div id="cd2" style="width: 250px;height: 250px;border-color: var(--bs-body-color);">	<script type="module">

	import * as THREE from 'three';
	import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
	import { RenderPixelatedPass } from 'three/addons/postprocessing/RenderPixelatedPass.js';
	import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
	import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

	let camera, scene, renderer, composer, clock, mixer;
	let animations; // Store animations here
	let params, model;
	let modelBoundingBox, boundingBoxHelper;

	const myContainer = 'cd2';

	init();
	animate();

	function init()
	{
		// Global variables
		const container = document.getElementById(myContainer);
		const containerWidth = container.clientWidth;
		const containerHeight = container.clientHeight;
		const aspectRatio = containerWidth / containerHeight;
		clock = new THREE.Clock();
		scene = new THREE.Scene();
		params = {
			pixelSize: 2,
			normalEdgeStrength: .3,
			depthEdgeStrength: .4,
			pixelAlignedPanning: true
		};
		
		// Camera setup
		camera = new THREE.OrthographicCamera(-aspectRatio, aspectRatio, 1, -1, 0.1, 10);
		camera.position.set(0, 1, 5);
		camera.lookAt(scene.position);
		camera.zoom = 7;
		
		// Renderer setup
		renderer = new THREE.WebGLRenderer(
		{
			antialias: true,
			alpha: true // Enable transparency
		});
		renderer.shadowMap.enabled = true;
		renderer.setSize(containerWidth, containerHeight);
		container.appendChild(renderer.domElement); // Append to the container
		composer = new EffectComposer(renderer);
		const renderPixelatedPass = new RenderPixelatedPass(2, scene, camera);
		composer.addPass(renderPixelatedPass);
		const outputPass = new OutputPass();
		composer.addPass(outputPass);



		// lights
		scene.add(new THREE.AmbientLight(0x757f8e, 3));
		const directionalLight = new THREE.DirectionalLight(0xfffecd, 1.5);
		directionalLight.position.set(100, 100, 100);
		directionalLight.castShadow = true;
		directionalLight.shadow.mapSize.set(2048, 2048);
		scene.add(directionalLight);

		const spotLight = new THREE.SpotLight(0xffc100, 10, 10, Math.PI / 16, .02, 2);
		spotLight.position.set(2, 2, 0);
		const target = spotLight.target;
		scene.add(target);
		target.position.set(0, 0, 0);
		spotLight.castShadow = true;
		scene.add(spotLight);
		

		// Handle Models
		const loader = new GLTFLoader().setPath('models/web/');
		loader.load('aiitk/cdaiitk.gltf', async function(gltf) {
			model = gltf.scene;
			animations = gltf.animations;
			mixer = new THREE.AnimationMixer(model);

			await renderer.compileAsync(model, camera, scene);
			scene.add(model);
			
			//Initialize the bounding box and its helper
			modelBoundingBox = new THREE.Box3().setFromObject(model);
			boundingBoxHelper = new THREE.Box3Helper(modelBoundingBox, 0xff0000);
			//scene.add(boundingBoxHelper); // Optional: Add the bounding box helper for visualization
			//modelBoundingBox.addEventListener('mouseclick', onModelClick);
		
		});
		
		

		// Events to listen to
		window.addEventListener('resize', onWindowResize);
		container.addEventListener('mousemove', onMouseMove);
		container.addEventListener('mouseleave', onMouseMove);

	}



	function onMouseMove(event) {
		event.preventDefault();

		const raycaster = new THREE.Raycaster();
		const mouse = new THREE.Vector2();
		const bounds = renderer.domElement.getBoundingClientRect();

		mouse.x = ((event.clientX - bounds.left) / bounds.width) * 2 - 1;
		mouse.y = -((event.clientY - bounds.top) / bounds.height) * 2 + 1;
		raycaster.setFromCamera(mouse, camera);

		// Update the bounding box to the current state of the model.
		//const currentBoundingBox = new THREE.Box3().setFromObject(model);

		if (modelBoundingBox && raycaster.ray.intersectBox(modelBoundingBox, new THREE.Vector3())) {
			document.body.style.cursor = 'pointer'; // Change cursor to indicate interactive element
			if (!model.userData.isHovered) {
				model.userData.isHovered = true; // Flag to indicate hover state
				playAnimation(1); // Play animation forwards only if it wasn't already hovering
			}
		} else {
			document.body.style.cursor = 'default'; // Change cursor back to default
			if (model.userData.isHovered) {
				model.userData.isHovered = false; // Reset hover state flag
				playAnimation(-1); // Play animation in reverse since mouse has left
			}
		}
	}

	function playAnimation(direction) {
		// Function to control animation playback
		if (mixer && animations.length > 0) {
			const action = mixer.clipAction(animations[0]);
			action.setEffectiveTimeScale(direction); // Direction controls the playback direction
			if(direction === 1 && !action.isRunning()) {
				action.setLoop(THREE.LoopOnce);
				action.clampWhenFinished = true;
				action.enabled = true;
				action.play();
			} else if(direction === -1) {
				action.enabled = true;
				action.paused = false;
				action.clampWhenFinished = false;
				action.play();
			}
		}
	}

	function animate()
	{

		requestAnimationFrame(animate);


		// Ensure mixer is defined before attempting to update it
		if (mixer) mixer.update(clock.getDelta());

		const t = clock.getElapsedTime();
		
		
		// Update the bounding box and helper in every frame
		if (model && modelBoundingBox) {
			modelBoundingBox.setFromObject(model);
		}

		// Pixel Effect
		const rendererSize = renderer.getSize(new THREE.Vector2());
		const aspectRatio = rendererSize.x / rendererSize.y;
		if (params['pixelAlignedPanning'])
		{

			pixelAlignFrustum(camera, aspectRatio, Math.floor(rendererSize.x / params['pixelSize']),
				Math.floor(rendererSize.y / params['pixelSize']));

		}
		else if (camera.left != -aspectRatio || camera.top != 1.0)
		{

			// Reset the Camera Frustum if it has been modified
			camera.left = -aspectRatio;
			camera.right = aspectRatio;
			camera.top = 1.0;
			camera.bottom = -1.0;
			camera.updateProjectionMatrix();

		}

		composer.render();

	}
	
	// Helper
	
	function onWindowResize()
	{
		const container = document.getElementById(myContainer);
		const containerWidth = container.clientWidth;
		const containerHeight = container.clientHeight;
		const aspectRatio = containerWidth / containerHeight;
		camera.left = -aspectRatio;
		camera.right = aspectRatio;
		camera.updateProjectionMatrix();

		renderer.setSize(containerWidth, containerHeight);
		composer.setSize(containerWidth, containerHeight);
	}
	
	


	function pixelTexture(texture)
	{

		texture.minFilter = THREE.NearestFilter;
		texture.magFilter = THREE.NearestFilter;
		texture.generateMipmaps = false;
		texture.wrapS = THREE.RepeatWrapping;
		texture.wrapT = THREE.RepeatWrapping;
		texture.colorSpace = THREE.SRGBColorSpace;
		return texture;

	}

	function pixelAlignFrustum(camera, aspectRatio, pixelsPerScreenWidth, pixelsPerScreenHeight)
	{

		// 0. Get Pixel Grid Units
		const worldScreenWidth = ((camera.right - camera.left) / camera.zoom);
		const worldScreenHeight = ((camera.top - camera.bottom) / camera.zoom);
		const pixelWidth = worldScreenWidth / pixelsPerScreenWidth;
		const pixelHeight = worldScreenHeight / pixelsPerScreenHeight;

		// 1. Project the current camera position along its local rotation bases
		const camPos = new THREE.Vector3();
		camera.getWorldPosition(camPos);
		const camRot = new THREE.Quaternion();
		camera.getWorldQuaternion(camRot);
		const camRight = new THREE.Vector3(1.0, 0.0, 0.0).applyQuaternion(camRot);
		const camUp = new THREE.Vector3(0.0, 1.0, 0.0).applyQuaternion(camRot);
		const camPosRight = camPos.dot(camRight);
		const camPosUp = camPos.dot(camUp);

		// 2. Find how far along its position is along these bases in pixel units
		const camPosRightPx = camPosRight / pixelWidth;
		const camPosUpPx = camPosUp / pixelHeight;

		// 3. Find the fractional pixel units and convert to world units
		const fractX = camPosRightPx - Math.round(camPosRightPx);
		const fractY = camPosUpPx - Math.round(camPosUpPx);

		// 4. Add fractional world units to the left/right top/bottom to align with the pixel grid
		camera.left = -aspectRatio - (fractX * pixelWidth);
		camera.right = aspectRatio - (fractX * pixelWidth);
		camera.top = 1.0 - (fractY * pixelHeight);
		camera.bottom = -1.0 - (fractY * pixelHeight);
		camera.updateProjectionMatrix();

	}

</script></div></a><a href="#SmackInfo"><div id="cd3" style="width: 250px;height: 250px;border-color: var(--bs-body-color);">	<script type="module">

	import * as THREE from 'three';
	import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
	import { RenderPixelatedPass } from 'three/addons/postprocessing/RenderPixelatedPass.js';
	import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
	import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

	let camera, scene, renderer, composer, clock, mixer;
	let animations; // Store animations here
	let params, model;
	let modelBoundingBox, boundingBoxHelper;

	const myContainer = 'cd3';

	init();
	animate();

	function init()
	{
		// Global variables
		const container = document.getElementById(myContainer);
		const containerWidth = container.clientWidth;
		const containerHeight = container.clientHeight;
		const aspectRatio = containerWidth / containerHeight;
		clock = new THREE.Clock();
		scene = new THREE.Scene();
		params = {
			pixelSize: 2,
			normalEdgeStrength: .3,
			depthEdgeStrength: .4,
			pixelAlignedPanning: true
		};
		
		// Camera setup
		camera = new THREE.OrthographicCamera(-aspectRatio, aspectRatio, 1, -1, 0.1, 10);
		camera.position.set(0, 1, 5);
		camera.lookAt(scene.position);
		camera.zoom = 7;
		
		// Renderer setup
		renderer = new THREE.WebGLRenderer(
		{
			antialias: true,
			alpha: true // Enable transparency
		});
		renderer.shadowMap.enabled = true;
		renderer.setSize(containerWidth, containerHeight);
		container.appendChild(renderer.domElement); // Append to the container
		composer = new EffectComposer(renderer);
		const renderPixelatedPass = new RenderPixelatedPass(2, scene, camera);
		composer.addPass(renderPixelatedPass);
		const outputPass = new OutputPass();
		composer.addPass(outputPass);



		// lights
		scene.add(new THREE.AmbientLight(0x757f8e, 3));
		const directionalLight = new THREE.DirectionalLight(0xfffecd, 1.5);
		directionalLight.position.set(100, 100, 100);
		directionalLight.castShadow = true;
		directionalLight.shadow.mapSize.set(2048, 2048);
		scene.add(directionalLight);

		const spotLight = new THREE.SpotLight(0xffc100, 10, 10, Math.PI / 16, .02, 2);
		spotLight.position.set(2, 2, 0);
		const target = spotLight.target;
		scene.add(target);
		target.position.set(0, 0, 0);
		spotLight.castShadow = true;
		scene.add(spotLight);
		

		// Handle Models
		const loader = new GLTFLoader().setPath('models/web/');
		loader.load('aiitk/cdaiitk.gltf', async function(gltf) {
			model = gltf.scene;
			animations = gltf.animations;
			mixer = new THREE.AnimationMixer(model);

			await renderer.compileAsync(model, camera, scene);
			scene.add(model);
			
			//Initialize the bounding box and its helper
			modelBoundingBox = new THREE.Box3().setFromObject(model);
			boundingBoxHelper = new THREE.Box3Helper(modelBoundingBox, 0xff0000);
			scene.add(boundingBoxHelper); // Optional: Add the bounding box helper for visualization
			//modelBoundingBox.addEventListener('mouseclick', onModelClick);
		
		});
		
		

		// Events to listen to
		window.addEventListener('resize', onWindowResize);
		container.addEventListener('mousemove', onMouseMove);
		container.addEventListener('mouseleave', onMouseMove);

	}



	function onMouseMove(event) {
		event.preventDefault();

		const raycaster = new THREE.Raycaster();
		const mouse = new THREE.Vector2();
		const bounds = renderer.domElement.getBoundingClientRect();

		mouse.x = ((event.clientX - bounds.left) / bounds.width) * 2 - 1;
		mouse.y = -((event.clientY - bounds.top) / bounds.height) * 2 + 1;
		raycaster.setFromCamera(mouse, camera);

		// Update the bounding box to the current state of the model.
		//const currentBoundingBox = new THREE.Box3().setFromObject(model);

		if (modelBoundingBox && raycaster.ray.intersectBox(modelBoundingBox, new THREE.Vector3())) {
			document.body.style.cursor = 'pointer'; // Change cursor to indicate interactive element
			if (!model.userData.isHovered) {
				model.userData.isHovered = true; // Flag to indicate hover state
				playAnimation(1); // Play animation forwards only if it wasn't already hovering
			}
		} else {
			document.body.style.cursor = 'default'; // Change cursor back to default
			if (model.userData.isHovered) {
				model.userData.isHovered = false; // Reset hover state flag
				playAnimation(-1); // Play animation in reverse since mouse has left
			}
		}
	}

	function playAnimation(direction) {
		// Function to control animation playback
		if (mixer && animations.length > 0) {
			const action = mixer.clipAction(animations[0]);
			action.setEffectiveTimeScale(direction); // Direction controls the playback direction
			if(direction === 1 && !action.isRunning()) {
				action.setLoop(THREE.LoopOnce);
				action.clampWhenFinished = true;
				action.enabled = true;
				action.play();
			} else if(direction === -1) {
				action.enabled = true;
				action.paused = false;
				action.clampWhenFinished = false;
				action.play();
			}
		}
	}

	function animate()
	{

		requestAnimationFrame(animate);


		// Ensure mixer is defined before attempting to update it
		if (mixer) mixer.update(clock.getDelta());

		const t = clock.getElapsedTime();
		
		
		// Update the bounding box and helper in every frame
		if (model && modelBoundingBox) {
			modelBoundingBox.setFromObject(model);
		}

		// Pixel Effect
		const rendererSize = renderer.getSize(new THREE.Vector2());
		const aspectRatio = rendererSize.x / rendererSize.y;
		if (params['pixelAlignedPanning'])
		{

			pixelAlignFrustum(camera, aspectRatio, Math.floor(rendererSize.x / params['pixelSize']),
				Math.floor(rendererSize.y / params['pixelSize']));

		}
		else if (camera.left != -aspectRatio || camera.top != 1.0)
		{

			// Reset the Camera Frustum if it has been modified
			camera.left = -aspectRatio;
			camera.right = aspectRatio;
			camera.top = 1.0;
			camera.bottom = -1.0;
			camera.updateProjectionMatrix();

		}

		composer.render();

	}
	
	// Helper
	
	function onWindowResize()
	{
		const container = document.getElementById(myContainer);
		const containerWidth = container.clientWidth;
		const containerHeight = container.clientHeight;
		const aspectRatio = containerWidth / containerHeight;
		camera.left = -aspectRatio;
		camera.right = aspectRatio;
		camera.updateProjectionMatrix();

		renderer.setSize(containerWidth, containerHeight);
		composer.setSize(containerWidth, containerHeight);
	}
	
	


	function pixelTexture(texture)
	{

		texture.minFilter = THREE.NearestFilter;
		texture.magFilter = THREE.NearestFilter;
		texture.generateMipmaps = false;
		texture.wrapS = THREE.RepeatWrapping;
		texture.wrapT = THREE.RepeatWrapping;
		texture.colorSpace = THREE.SRGBColorSpace;
		return texture;

	}

	function pixelAlignFrustum(camera, aspectRatio, pixelsPerScreenWidth, pixelsPerScreenHeight)
	{

		// 0. Get Pixel Grid Units
		const worldScreenWidth = ((camera.right - camera.left) / camera.zoom);
		const worldScreenHeight = ((camera.top - camera.bottom) / camera.zoom);
		const pixelWidth = worldScreenWidth / pixelsPerScreenWidth;
		const pixelHeight = worldScreenHeight / pixelsPerScreenHeight;

		// 1. Project the current camera position along its local rotation bases
		const camPos = new THREE.Vector3();
		camera.getWorldPosition(camPos);
		const camRot = new THREE.Quaternion();
		camera.getWorldQuaternion(camRot);
		const camRight = new THREE.Vector3(1.0, 0.0, 0.0).applyQuaternion(camRot);
		const camUp = new THREE.Vector3(0.0, 1.0, 0.0).applyQuaternion(camRot);
		const camPosRight = camPos.dot(camRight);
		const camPosUp = camPos.dot(camUp);

		// 2. Find how far along its position is along these bases in pixel units
		const camPosRightPx = camPosRight / pixelWidth;
		const camPosUpPx = camPosUp / pixelHeight;

		// 3. Find the fractional pixel units and convert to world units
		const fractX = camPosRightPx - Math.round(camPosRightPx);
		const fractY = camPosUpPx - Math.round(camPosUpPx);

		// 4. Add fractional world units to the left/right top/bottom to align with the pixel grid
		camera.left = -aspectRatio - (fractX * pixelWidth);
		camera.right = aspectRatio - (fractX * pixelWidth);
		camera.top = 1.0 - (fractY * pixelHeight);
		camera.bottom = -1.0 - (fractY * pixelHeight);
		camera.updateProjectionMatrix();

	}

</script></div></a></div></div><div class="container" style="padding-top: 131px;"><div class="vstack"><section id="SmackInfo" class="py-4 py-xl-5"><div class="container"><div class="bg-dark border rounded border-0 border-dark overflow-hidden"><div class="row g-0"><div class="col-md-6"><div class="d-md-flex justify-content-md-center align-items-md-center" style="padding: 20px;"><img class="rounded" src="assets/img/SmackHero.png" style="width: 323px;box-shadow: 0px 0px 8px 5px var(--bs-emphasis-color);"></div><div class="text-white p-4 p-md-5"><h2 class="fw-bold text-white mb-3" style="font-family: Aldrich, sans-serif;">S.M.A.C.K.</h2><p class="mb-4" style="font-family: 'Ubuntu Mono', monospace;">S.M.A.C.K. is an online multiplayer, third-person sandbox shooter, where you suck ordinary objects into your personal particle-izer and fire them at your friends with specialized weapons placed within the environment. ANYTHING IS AMMO! </p><div class="my-3" style="font-family: 'Ubuntu Mono', monospace;"><a class="btn btn-primary btn-lg me-2" role="button" href="https://store.steampowered.com/app/2118060/SMACK/" style="background: var(--bs-emphasis-color);border-style: solid;border-color: var(--bs-btn-disabled-color);">Steam</a><a class="btn btn-light btn-lg" role="button" href="https://discord.gg/TQ3yaW5U" style="border-style: solid;border-color: var(--bs-btn-disabled-color);">Discord</a></div></div></div><div class="col-md-6 order-first order-md-last" style="min-height: 250px;"><iframe allowfullscreen="" frameborder="0" src="https://www.youtube.com/embed/6uNrNbtvV04?autoplay=1&amp;mute=1&amp;loop=1&amp;playlist=6uNrNbtvV04" class="w-100 h-100 fit-cover" width="560" height="315"></iframe></div></div></div></div></section><section id="SmackInfo-1" class="py-4 py-xl-5"><div class="container"><div class="bg-dark border rounded border-0 border-dark overflow-hidden"><div class="row g-0"><div class="col-md-6"><div class="d-md-flex justify-content-md-center align-items-md-center" style="padding: 20px;"><img class="rounded" src="assets/img/V2LogoFinal.png" style="width: 159px;box-shadow: 0px 0px 8px 5px var(--bs-emphasis-color);"></div><div class="text-white p-4 p-md-5"><h2 class="fw-bold text-white mb-3" style="font-family: Aldrich, sans-serif;">AI Integration Toolkit</h2><p class="mb-4" style="font-family: 'Ubuntu Mono', monospace;">The AI Integration Toolkit plugin for Unreal Engine is a comprehensive suite of tools designed to seamlessly integrate OpenAI's GPT, Dall-E, Whisper, and TTS APIs into your Unreal Engine projects as well as Eleven Labs text to speech for a variety of realistic voices. This plugin offers an extensive range of functions and events that make it easy to incorporate chat and function-based AI, image generation, speech generation, and audio transcription services into your games. My goal is to make it as easy as possible to integrate generative AI into your projects and with AIITK you can get started with as little as 2 nodes. </p><div class="my-3" style="font-family: 'Ubuntu Mono', monospace;"><a class="btn btn-primary btn-lg me-2" role="button" href="#" style="background: var(--bs-emphasis-color);border-style: solid;border-color: var(--bs-btn-disabled-color);">UE Marketplace</a><a class="btn btn-light btn-lg" role="button" href="#" style="border-style: solid;border-color: var(--bs-btn-disabled-color);">Discord</a></div></div></div><div class="col-md-6 order-first order-md-last" style="min-height: 250px;"><iframe allowfullscreen="" frameborder="0" src="https://www.youtube.com/embed/4wl4-j9jsBo?autoplay=1&amp;mute=1&amp;loop=1&amp;playlist=4wl4-j9jsBo" class="w-100 h-100 fit-cover" width="560" height="315"></iframe></div></div></div></div></section><section id="SmackInfo-2" class="py-4 py-xl-5"><div class="container"><div class="bg-dark border rounded border-0 border-dark overflow-hidden"><div class="row g-0"><div class="col-md-6"><div class="d-md-flex justify-content-md-center align-items-md-center" style="padding: 20px;"><img class="rounded" src="assets/img/Foundationimg.jpg" style="width: 323px;box-shadow: 0px 0px 8px 5px var(--bs-emphasis-color);"></div><div class="text-white p-4 p-md-5"><h2 class="fw-bold text-white mb-3" style="font-family: Aldrich, sans-serif;">Foundation Collection</h2><p class="mb-4" style="font-family: 'Ubuntu Mono', monospace;">This is everything I've ever put on itch.io. Essentially a collection of my early works up to 2021. Includes game jams, experiments, and college work.</p><div class="my-3" style="font-family: 'Ubuntu Mono', monospace;"><a class="btn btn-primary btn-lg me-2" role="button" href="#" style="background: var(--bs-emphasis-color);border-style: solid;border-color: var(--bs-btn-disabled-color);">Steam</a><a class="btn btn-light btn-lg" role="button" href="#" style="border-style: solid;border-color: var(--bs-btn-disabled-color);">Discord</a></div></div></div><div class="col-md-6 order-first order-md-last" style="min-height: 250px;"><iframe allowfullscreen="" frameborder="0" src="https://www.youtube.com/embed/aIv8zkLXav8?autoplay=1&amp;mute=1&amp;loop=1&amp;playlist=aIv8zkLXav8" class="w-100 h-100 fit-cover" width="560" height="315"></iframe></div></div></div></div></section></div></div><footer class="footer text-center"><div class="container"><p class="text-muted mb-0 small">Copyright &nbsp;© Kaleb Knoettgen 2024</p></div><a class="js-scroll-trigger scroll-to-top rounded" href="#page-top"><i class="fa fa-angle-up"></i></a></footer><script src="assets/bootstrap/js/bootstrap.min.js"></script><script src="assets/js/script.min.js"></script></body></html>