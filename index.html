<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Pixelated 3D Object with Animation on Hover</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
    </style>
</head>
<body>
<script type="module">
import * as THREE from './three.module.min.js';
import { FBXLoader } from './loaders/FBXLoader.js'; // Adjust the path as necessary

let scene, camera, renderer, clock, raycaster, mouse;

function init() {
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 5;

    renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    clock = new THREE.Clock();

    raycaster = new THREE.Raycaster();
    mouse = new THREE.Vector2();

    window.addEventListener('mousemove', onMouseMove, false);

    loadFBXObject();
}

function onMouseMove(event) {
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
}

function loadFBXObject() {
    const loader = new FBXLoader();
    loader.load('model.fbx', function(object) {
        object.traverse(function(child) {
            if (child.isMesh) {
                child.material.magFilter = THREE.NearestFilter;
                child.material.minFilter = THREE.LinearFilter;
            }
        });

        const mixer = new THREE.AnimationMixer(object);
        const action = mixer.clipAction(object.animations[0]);
        object.userData = { mixer, action };

        scene.add(object);
    });
}

function checkHover() {
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObjects(scene.children, true);

    if (intersects.length > 0) {
        const object = intersects[0].object;
        if (object.userData.mixer && !object.userData.action.isRunning()) {
            object.userData.action.play();
        }
    }
}

function animate() {
    requestAnimationFrame(animate);

    const delta = clock.getDelta();
    scene.traverse(child => {
        if (child.userData.mixer) {
            child.userData.mixer.update(delta);
        }
    });

    checkHover();
    renderer.render(scene, camera);
}

init();
animate();
</script>
</body>
</html>
